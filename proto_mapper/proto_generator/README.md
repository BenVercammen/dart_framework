The purpose of this package, alongside its companion proto_annotations package, is to significantly reduce the workload of exposing Dart business model classes as protocol buffer messages to be used with gRPC.

## Workflow

Let's assume we want to represent the concept of a recipe. 

### Without this package

One way of going about it is by creating a .proto file and include a message to represent the concept, and then run the protoc compiler to generate a dart file that represents the concept and serializes and deserializes itself to protobuffers to be used with gRPC.

There are limitations to this approach. One, for instance, is that .proto files do not support inheritance. We might also want to add business logic and validations to our business model, which will not be trivial, if at all possible, using the classes generated by protoc. Finally, there is no easy way to extend the compiled classes to add properties we actually do not want to serialize.

Another way of using protocol buffers is to go over the tedious work of typing our business model classes, adding whichever features we want to, typing .proto files containing message structures, generating dart classes that represent the .proto files and manually create functions that map from the business dart classes to the .proto classes. 

### With proto_annotations

With this package and proto_annotations, we get the flexibility of typing our dart business model, but without the tedious work of typing the matching .proto files and corresponding mapping code, eliminating a lot of busy work.

We begin by typing our business model. The next step is to use the proto_generator package to generate the corresponding .proto files, instead manually typing them. The proto_generator package also generates functions that map instances of the business model to instances of the corresponding classes that are generated by the protoc compiler. The final step is run the protoc compiler to generate the dart classes that represent the messages present in the generated .proto files.

## Getting started

In order to get started, look at the example project at https://github.com/squarealfa/dart_framework/tree/main/proto_mapper/example.

### Using Map\<?, ?> types in @proto/@mapProto annotated classes
It is possible to make use of Map types, but only when adhering to the following rules:
 - keys should be primitive values (ie: String, int, ... )
 - values can be primitives or objects, but not a collection type

See https://developers.google.com/protocol-buffers/docs/proto3#maps for more information regarding the limits of Maps in protocol buffers. 

### Making use of dynamic values
`dynamic` and `Object` typed fields or collection values are also supported. 
In the `.proto` files, these translate into `google.protobuf.Any` fields.
In the generated mappers, they'll be "packed" and "unpacked" using the `Any` class/extension.

Please note that in order to actually use this, you'll have to set up the following:
 - The `any.proto` file needs to be available when running `protoc`. This can be done by adding `-I%PROTOC_HOME%/include` to the `protoc` command, where `%PROTOC_HOME` points to the location of your **protoc** installation.
 - The `any.pb[enum|json|server].dart` files need to be generated and added to the `lib/grpc` folder.
    ```
     cd ./dart_framework/proto_mapper/test
     protoc --dart_out=grpc:lib/grpc -I%PROTOC_HOME%/include %PROTOC_HOME%/include/google/protobuf/any.proto
    ```

See https://developers.google.com/protocol-buffers/docs/proto3#any for more information.

## Context

This package is part of a set of losely integrated packages that constitute the [SquareAlfa Dart Framework](https://github.com/squarealfa/dart_framework#squarealfa-dart-framework).
